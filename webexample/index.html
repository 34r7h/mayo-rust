<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAYO Wasm Example</title>
    <style>
        pre {
            white-space: pre-wrap; /* Ensure text wraps and respects newlines */
            word-wrap: break-word;
            background-color: #f0f0f0;
            padding: 10px;
            border: 1px solid #ccc;
            min-height: 50px; /* Give it some initial height */
        }
    </style>
</head>
<body>
    <h1>MAYO Wasm Demo</h1>

    <button id="generate-keys">Generate Keys</button>
    <button id="sign-message" disabled>Sign Message</button>
    <button id="verify-signature" disabled>Verify Signature</button>

    <h2>Output:</h2>
    <pre id="output"></pre>

    <script type="module">
        import init, { keypair, sign, open } from '../pkg/identity.js';

        const output = document.getElementById('output');
        const generateBtn = document.getElementById('generate-keys');
        const signBtn = document.getElementById('sign-message');
        const verifyBtn = document.getElementById('verify-signature');

        let csk_object = null; // Renamed from csk_bytes
        let cpk_object = null; // Renamed from cpk_bytes
        let signature_object = null; // Renamed from signature_bytes
        const message = new TextEncoder().encode("This is a test message");

        function appendOutput(text) {
            const textNode = document.createTextNode(text + '\n');
            output.appendChild(textNode);
            // Auto-scroll to bottom
            output.scrollTop = output.scrollHeight;
        }

        function setButtonState(generate, sign, verify) {
            generateBtn.disabled = generate;
            signBtn.disabled = sign;
            verifyBtn.disabled = verify;
        }

        async function run() {
            appendOutput('Loading Wasm...');
            setButtonState(true, true, true); // Disable all buttons initially
            try {
                await init();
                appendOutput('Wasm loaded successfully.');
                setButtonState(false, true, true); // Enable generate button
            } catch (e) {
                appendOutput(`Error loading Wasm: ${e}`);
                console.error('Error loading Wasm:', e);
                // Buttons remain disabled on Wasm load failure
            }
        }

        generateBtn.addEventListener('click', () => {
            setButtonState(true, true, true); // Disable buttons
            const mayo_variant = "mayo1";
            appendOutput(`Generating keys for ${mayo_variant}...`);
            try {
                const keypair_wrapper = keypair(mayo_variant);
                csk_object = keypair_wrapper.sk; // Store the object directly
                cpk_object = keypair_wrapper.pk; // Store the object directly

                // keypair_wrapper.free(); // Consider if sk or pk objects themselves need freeing if get_bytes() clones.
                                        // If CompactSecretKey/CompactPublicKey are #[wasm_bindgen(getter_with_clone)]
                                        // and get_bytes returns Vec<u8> (which becomes Uint8Array),
                                        // the original JS objects keypair_wrapper.sk and keypair_wrapper.pk might need freeing
                                        // if they are not immediately garbage collected.
                                        // For now, let's assume wasm-bindgen handles this reasonably.
                                        // The keypair_wrapper itself might also need freeing: keypair_wrapper.free();
                                        // Let's defer explicit freeing unless memory issues are observed.

                appendOutput('Compact keys generated successfully.');
                appendOutput(`  CSK length: ${csk_object.get_bytes().length} bytes`); // Use get_bytes() for length
                appendOutput(`  CPK length: ${cpk_object.get_bytes().length} bytes`); // Use get_bytes() for length
                // Removed logging for esk_bytes and epk_bytes

                setButtonState(true, false, true); // Enable sign button
            } catch (e) {
                appendOutput(`Error generating keys: ${e}`);
                console.error('Error generating keys:', e);
                setButtonState(false, true, true); // Re-enable generate on error
            }
        });

        signBtn.addEventListener('click', () => {
            setButtonState(true, true, true); // Disable buttons
            const mayo_variant = "mayo1";
            appendOutput(`Signing message with ${mayo_variant}...`);
             try {
                const sig_obj = sign(csk_object, message, mayo_variant); // Use csk_object
                signature_object = sig_obj; // Store the signature object

                appendOutput('Message signed successfully.');
                appendOutput(`  Signature length: ${signature_object.get_bytes().length} bytes`); // Use get_bytes() for length

                setButtonState(true, true, false); // Enable verify button
            } catch (e) {
                appendOutput(`Error signing message: ${e}`);
                console.error('Error signing message:', e);
                setButtonState(true, false, true); // Re-enable sign on error
            }
        });

         verifyBtn.addEventListener('click', () => {
            setButtonState(true, true, true); // Disable buttons
            const mayo_variant = "mayo1";
            appendOutput(`Verifying signature with ${mayo_variant}...`);
             try {
                // Construct signed_message = signature_bytes || message
                let actual_signature_bytes = signature_object.get_bytes(); // Get bytes from signature_object
                let signed_message_js = new Uint8Array(actual_signature_bytes.length + message.length);
                signed_message_js.set(actual_signature_bytes);
                signed_message_js.set(message, actual_signature_bytes.length);

                const recovered_message_option = open(cpk_object, signed_message_js, mayo_variant); // Use cpk_object

                if (recovered_message_option) {
                    // Optional: Compare recovered_message_option with original message for completeness
                    let messages_match = recovered_message_option.length === message.length && 
                                         recovered_message_option.every((val, idx) => val === message[idx]);
                    appendOutput(`Verification successful: true`);
                    appendOutput(`  Recovered message matches original: ${messages_match}`);
                } else {
                    appendOutput(`Verification successful: false (signature invalid or error)`);
                }
                // Keep buttons disabled or reset as appropriate after verification
                setButtonState(true, true, true); // Example: disable all after one full cycle.
            } catch (e) {
                appendOutput(`Error verifying signature: ${e}`);
                console.error('Error verifying signature:', e);
                setButtonState(true, true, false); // Re-enable verify on error
            }
         });

        run();
    </script>
</body>
</html> 